<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - MMD loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: black;
				margin: 0;
				padding: 0;
			}

			a { color: skyblue }

			canvas {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				margin: auto;
			}

			#info {
				color: white;
				font-size: 13px;
				position: absolute;
				bottom: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl pathtracing example<br />
			by <a href="https://github.com/gam0022" target="_blank">gam0022</a> (<a href="http://qiita.com/gam0022/items/9875480d33e03fe2113c" target="_blank">article in Japanese</a>)
		</div>

<script id="vertex_shader" type="x-shader/x-vertex">
attribute vec3 position;
void main(void) {
	gl_Position = vec4( position, 1.0 );
}
</script>

<script id="float_fragment_shader" type="x-shader/x-fragment">
precision highp float;

// uniforms
uniform float time;
uniform int frame;
uniform sampler2D buffer;
uniform vec2 resolution;

// camera
uniform vec3 cameraPosition;
uniform mat4 viewMatrix;

uniform mat4 cameraWorldMatrix;
uniform mat4 cameraProjectionMatrixInverse;
uniform mat4 cameraViewProjectionpMatrixInverse;
uniform float cameraNear;
uniform float cameraFar;

// consts
const float INF = 1e+10;
const float EPS = 1e-4;
const float OFFSET = EPS * 10.0;
const float PI = 3.14159265359;
const vec3 backgroundColor = vec3( 1.0 );

// global
//vec4 state;

struct Ray {
	vec3 origin;
	vec3 direction;
};

struct Material {
	int type;
	vec3 color;
};
#define MATERIAL_TYPE_DIFFUSE 0

struct Intersection {
	bool hit;
	vec3 position;
	float distance;
	vec3 normal;
	Material material;
};

struct Sphere {
	float radius;
	vec3 position;
	Material material;
};

struct Plane {
	vec3 position;
	vec3 normal;
	Material material;
};

float hash(float x) {
    return fract(sin(x)*43758.5453123);
}

float GPURnd() {
	const vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);
	const vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);
	const vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);
	const vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);

	vec4 beta = floor(state / q);
	vec4 p = a * (state - beta * q) - beta * r;
	beta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;
	state = (p + beta);

	return fract(dot(state / m, vec4(1.0, -1.0, 1.0, -1.0)));
}

vec3 cosineDirection( float seed, vec3 nor ) {
	// compute basis from normal
	// see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content
	// (link provided by nimitz)
	vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);
	vec3 uu = vec3( tc.x, tc.z, -nor.x );
	vec3 vv = vec3( tc.z, tc.y, -nor.y );

	//float u = GPURnd();//hash( 78.233 + seed);
	//float v = GPURnd();//hash( 10.873 + seed);
	float u = hash( 78.233 + seed);
	float v = hash( 10.873 + seed);
	float a = 6.283185 * v;

	return sqrt( u ) * ( cos( a ) * uu + sin( a ) * vv ) + sqrt( 1.0 - u ) * nor;
}

float udFloor( vec3 p ){
	return dot( p, vec3( 0.0, 1.0, 0.0 ) ) + 1.0;
}

float sdSphere( vec3 p, float r ) {
	return length( p ) - r;
}

float sdTorus( vec3 p, vec2 t ) {
	vec2 q = vec2( length( p.xz ) - t.x, p.y );
	return length( q ) - t.y;
}

float sceneDistance( vec3 p ) {
	return sdTorus( p - vec3( 3.0, 0.2, 0.0 ), vec2( 1.0, 0.2 ) );
	// return sdSphere( p, 1.0 );
	//return min( udFloor( p ), sdSphere( p, 1.0 ) );
}

vec3 calcNormal( vec3 p ) {
	vec2 e = vec2( 1.0, -1.0 ) * 0.001;
	return normalize(
		e.xyy * sceneDistance( p + e.xyy ) + e.yyx * sceneDistance( p + e.yyx ) + 
			e.yxy * sceneDistance( p + e.yxy ) + e.xxx * sceneDistance( p + e.xxx ) );
}

void intersectDistanceFucntion( inout Intersection intersection, Ray ray, Material material ) {
	float d;
	float distance = 0.0;
	vec3 p = ray.origin;

	for ( int i = 0; i < 200; i++ ) {
		d = sceneDistance( p );
		distance += d;
		p = ray.origin + distance * ray.direction;
		if ( abs( d ) < EPS ) break;
	}

	if ( abs( d ) < EPS ) {
		if ( distance < intersection.distance ) {
			intersection.hit = true;
			intersection.position = p;
			intersection.normal = calcNormal( p );
			intersection.distance = distance;
			intersection.material = material;
		}
	}
}

void intersectPlane( inout Intersection intersection, Ray ray, Plane plane ){
    float d = -dot( plane.position, plane.normal );
    float v = dot( ray.direction, plane.normal );
    float t = -( dot( ray.origin, plane.normal ) + d ) / v;

	if(t > EPS && t < intersection.distance){
		intersection.hit = true;
		intersection.position = ray.origin + ray.direction * t;
		intersection.normal = plane.normal;
		intersection.distance = t;
		intersection.material = plane.material;
	}
}

void intersectSphere( inout Intersection intersection, Ray ray, Sphere sphere ){
	vec3  a = ray.origin - sphere.position;
	float b = dot( a, ray.direction );
	float c = dot( a, a ) - sphere.radius * sphere.radius;
	float d = b * b - c;
	float t = -b - sqrt( d );

	if( d > 0.0 && t > EPS && t < intersection.distance ) {
		intersection.hit = true;
		intersection.position = ray.origin + ray.direction * t;
		intersection.normal = normalize( intersection.position - sphere.position );
		intersection.distance = t;
		intersection.material = sphere.material;
	}
}

void intersectScene( inout Intersection intersection, inout Ray ray ) {
	Plane plane;
	plane.material.type = MATERIAL_TYPE_DIFFUSE;
	plane.material.color = vec3( 0.5 );
	plane.position = vec3( 0.0, 0.0, 0.0 );
	plane.normal = vec3( 0.0, 1.0, 0.0 );
	intersectPlane( intersection, ray, plane );

	Material distanceMaterial;
	distanceMaterial.type = MATERIAL_TYPE_DIFFUSE;
	distanceMaterial.color = vec3( 0.4, 0.4, 0.8 );
	intersectDistanceFucntion( intersection, ray, distanceMaterial );

	Sphere sphere;
	sphere.material.type = MATERIAL_TYPE_DIFFUSE;
	sphere.material.color = vec3( 0.8, 0.4, 0.4 );
	sphere.position = vec3( 0.0, 1.0, 1.0 );
	sphere.radius = 1.0;
	intersectSphere( intersection, ray, sphere );
}

//
// http://qiita.com/doxas/items/477fda867da467116f8d
// https://github.com/gam0022/tsukihi/blob/master/object/sphere.h
//



void calcRadiance( inout Intersection intersection, inout Ray ray, int bounce, float sa ) {
	intersection.hit = false;
	intersection.distance = INF;
	intersection.material.color = backgroundColor;

	intersectScene( intersection, ray );

	if ( intersection.hit ) {
		ray.origin = intersection.position + OFFSET * intersection.normal;
		ray.direction = cosineDirection(76.2 + 73.1*float(bounce) + sa + 17.7*float(frame), intersection.normal);
	}
}

void main( void ) {
	// previous color
	vec2 uv = gl_FragCoord.xy / resolution.xy;
	vec4 prevColor = texture2D( buffer, uv );

	// sa
	float sa = hash( dot( gl_FragCoord.xy, vec2(12.9898, 78.233) ) + 1113.1*float(frame) );

	// fragment position
	vec2 fragPos = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;

	// camera and ray
	vec4 rayTip = cameraWorldMatrix * cameraProjectionMatrixInverse * vec4( fragPos.xy, 1.0, 1.0 );
	Ray ray;
	ray.origin = cameraPosition;
	ray.direction = normalize( rayTip.xyz );

	//// init state for GPURnd
	//state.x = hash(uv.x);
	//state.y = hash(uv.y + state.x);
	//state.z = hash(state.x + state.y);
	//state.w = hash(time + dot(state.xyz, vec3(1.0)));

	// bounce
	Intersection intersection;
	vec3 color = vec3( 1.0 );
	for ( int i = 0; i < 3; i++ ) {
		calcRadiance( intersection, ray, i, sa );
		color *= intersection.material.color;
		if ( !intersection.hit ) break;
	}

	gl_FragColor = vec4( prevColor.rgb + color, 1.0 );
	//gl_FragColor = vec4( color, 1.0 );
}
</script>

<script id="render_fragment_shader" type="x-shader/x-fragment">
precision highp float;

uniform int frame;
uniform vec2 resolution;
uniform sampler2D buffer;

void main(void) {
	vec2 uv = gl_FragCoord.xy / resolution.xy;
	vec4 color = texture2D( buffer, uv );
	gl_FragColor = vec4( color.rgb / float( frame + 1 ), 1.0 );
	//gl_FragColor = vec4( color.rgb, 1.0 );
}
</script>

		<script src="js/three.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>

			var container, stats;
			var camera, renderer;
			var orbitControls, prevOrbitControlsState = -1, prevCameraMatrixWorld;
			var renderQuad;
			var floatQuad, initTexture, readBuffer, writeBuffer;
			var frame = 0;
			var clock = new THREE.Clock();

			var config = {
				saveImage: function() {
					renderer.render( renderQuad.scene, camera );
					window.open( canvas.toDataURL() );
				},
				camera: 'Orbit',

				resolution: '512',
			};

			init();
			animate();

			function createQuadScene( parameters ) {
				var scene = new THREE.Scene();
				var geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
				var material = new THREE.RawShaderMaterial( {
					uniforms: parameters.uniforms,
					vertexShader: parameters.vertexShader,
					fragmentShader: parameters.fragmentShader,
				} );
				var plane = new THREE.Mesh( geometry, material );
				plane.frustumCulled = false;
				plane.position.z = -1;
				scene.add( plane );

				return {
					scene: scene,
					geometry: geometry,
					material: material,
				};
			}

			function createDataTexture( width, height ) {
				var data = new Float32Array( width * height * 4 );
			
				for (var k = 0, kl = data.length; k < kl; k += 4) {
					data[k]      = 0.0;
					data[k + 1]  = 0.0;
					data[k + 2]  = 0.0;
					data[k + 3]  = 1.0;
				}
			
				var texture = new THREE.DataTexture(
					data,
					width,
					height,
					THREE.RGBAFormat,
					THREE.FloatType);
			
				texture.needsUpdate = true;
			
				return texture;
			}

			function createRenderTarget( width, height ) {
				return new THREE.WebGLRenderTarget( width, height, {
					wrapS: THREE.RepeatWrapping,
					wrapT: THREE.RepeatWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					stencilBuffer: false,
					depthBuffer: false
				});
			}

			function initBuffers() {
				initTexture  = createDataTexture( canvas.width, canvas.height );
				readBuffer  = createRenderTarget( canvas.width, canvas.height );
				writeBuffer = readBuffer.clone();

				// float quad
				floatQuad = createQuadScene( {
					uniforms: {
						resolution: { type: 'v2', value: new THREE.Vector2( canvas.width, canvas.height ) },
						time: { type: 'f', value: 0.0 },
						frame: { type: 'i', value: frame },
						buffer: { type: 't', value: readBuffer.texture },

						cameraWorldMatrix: { type: 'm4', value: camera.matrixWorld },
						cameraProjectionMatrixInverse: { type: 'm4', value: new THREE.Matrix4().getInverse( camera.projectionMatrix ) },
						cameraViewProjectionpMatrixInverse: { type: 'm4', value: new THREE.Matrix4() },
						cameraNear: { type: 'f', value: camera.near },
						cameraFar:  { type: 'f', value: camera.far },
					},
					vertexShader: document.getElementById( 'vertex_shader' ).textContent,
					fragmentShader: document.getElementById( 'float_fragment_shader' ).textContent
				} );

				// render quad
				renderQuad = createQuadScene( {
					uniforms: {
						resolution: { type: 'v2', value: new THREE.Vector2( canvas.width, canvas.height ) },
						frame: { type: 'i', value: frame },
						buffer: { type: 't', value: writeBuffer.texture },
					},
					vertexShader: document.getElementById( 'vertex_shader' ).textContent,
					fragmentShader: document.getElementById( 'render_fragment_shader' ).textContent
				} );
			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 1, 8 );
				camera.lookAt( new THREE.Vector3( 0.0, 0.0, 0.0 ) );

				renderer = new THREE.WebGLRenderer();
				//renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( config.resolution, config.resolution );
				renderer.setClearColor( new THREE.Color( 0xffffff ) );
				canvas = renderer.domElement;
				container.appendChild( canvas );

				// check OES_texture_float
				if ( !renderer.extensions.get( "OES_texture_float" ) ) {
					alert( "No OES_texture_float support for float textures." );
					return;
				}

				orbitControls = new THREE.OrbitControls( camera, canvas );
				orbitControls.enablePan = true;
				orbitControls.keyPanSpeed = 0.01;
				orbitControls.enableDamping = false;
				orbitControls.dampingFactor = 0.015;
				orbitControls.enableZoom = true;
				orbitControls.zoomSpeed = 1;
				orbitControls.rotateSpeed = 0.8;
				orbitControls.autoRotate = false;
				orbitControls.autoRotateSpeed = 0.0;
				orbitControls.target = new THREE.Vector3( 0.0, 0.0, 0.0 );

				window.addEventListener( 'resize', onWindowResize, false );

				var gui = new dat.GUI();
				gui.add( config, 'saveImage' ).name( 'Save Image' );
				gui.add( config, 'camera', [ 'GLSL', 'Orbit' ] ).name( 'Camera' );

				// var shadowFolder = gui.addFolder('Shadow');
				// shadowFolder.add( config, 'shadowType', { Hard: 0, Soft1: 1, Soft2: 2 } ).name( 'Type');
				// shadowFolder.add( config, 'shadowIntensity', 0.0, 1.0 ).name( 'Intensity' );
				// shadowFolder.add( config, 'shadowSharpness', 0.0, 100.0 ).name( 'Sharpness' );
				// shadowFolder.open();

				gui.add( config, 'resolution', [ '256', '512', '800', 'full' ] ).name( 'Resolution' ).onChange( function( value ) {

					onWindowResize();

				} );

				stats = new Stats();
				document.body.appendChild( stats.domElement );

				onWindowResize();

			}

			function onWindowResize() {

				if ( config.resolution === 'full' ) {

					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;

				} else {

					canvas.width = config.resolution;
					canvas.height = config.resolution;

				}

				camera.aspect = canvas.width / canvas.height;
				camera.updateProjectionMatrix();

				renderer.setSize( canvas.width, canvas.height );
				initBuffers();
				frame = 0;

			}

			function animate( timestamp ) {

				requestAnimationFrame( animate );
				render( timestamp );

			}

			function render( timestamp ) {

				var delta = clock.getDelta();

				stats.begin();

				if ( config.camera === "Orbit" ) {
					orbitControls.update();
					var state = orbitControls.getState();
					if ( camera && prevCameraMatrixWorld && !camera.matrixWorld.equals( prevCameraMatrixWorld ) ) {
						frame = 0;
					}
					prevOrbitControlsState = state;
					prevCameraMatrixWorld = camera.matrixWorld.clone();
				}

				// float quad
				{
					// set uniforms
					floatQuad.material.uniforms.resolution.value = new THREE.Vector2( canvas.width, canvas.height );
					floatQuad.material.uniforms.time.value = timestamp * 0.001;
					floatQuad.material.uniforms.frame.value = frame;
					floatQuad.material.uniforms.buffer.value = frame === 0 ? initTexture : readBuffer.texture;

					// set camera uniforms
					{
						var cameraViewProjectionpMatrixInverse = camera.matrixWorld.clone();
						var cameraViewInverseMatrix = camera.matrixWorld;
						var cameraProjectionInverseMatrix = new THREE.Matrix4().getInverse( camera.projectionMatrix );
						//cameraViewProjectionpMatrixInverse.multiplyMatrices( cameraViewInverseMatrix, cameraProjectionInverseMatrix );
						cameraViewProjectionpMatrixInverse.multiply( cameraViewInverseMatrix );
						cameraViewProjectionpMatrixInverse.multiply( cameraProjectionInverseMatrix );
						floatQuad.material.uniforms.cameraViewProjectionpMatrixInverse.value = cameraViewProjectionpMatrixInverse;

						floatQuad.material.uniforms.cameraWorldMatrix.value = camera.matrixWorld;
						floatQuad.material.uniforms.cameraProjectionMatrixInverse.value = new THREE.Matrix4().getInverse( camera.projectionMatrix );

						floatQuad.material.uniforms.cameraNear.value = camera.near;
						floatQuad.material.uniforms.cameraFar.value  = camera.far;
					}

					renderer.render( floatQuad.scene, camera, writeBuffer );
				}

				// render quad
				{
					renderQuad.material.uniforms.resolution.value = new THREE.Vector2( canvas.width, canvas.height );
					renderQuad.material.uniforms.frame.value = frame;
					renderQuad.material.uniforms.buffer.value = writeBuffer.texture;

					renderer.render( renderQuad.scene, camera );
				}

				// swap buffers
				var tmpBuffer = writeBuffer;
				writeBuffer = readBuffer;
				readBuffer = tmpBuffer;

				stats.end();
				frame++;

			}
		</script>
	</body>
</html>
