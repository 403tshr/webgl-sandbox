<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - MMD loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: black;
				margin: 0;
				padding: 0;
			}

			a { color: skyblue }

			canvas {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				margin: auto;
			}

			#info {
				color: white;
				font-size: 13px;
				position: absolute;
				bottom: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
			}
		</style>
	</head>

	<body>
		<div id="info">
		<a href="http://threejs.org" target="_blank">three.js</a> - webgl pathtracing example<br />
		Copyright
		<a href="http://www.geocities.jp/higuchuu4/index_e.htm" target="_blank">Model Data</a>
		<a href="http://www.nicovideo.jp/watch/sm13147122" target="_blank">Dance Data</a>
		</div>

<script id="vertex_shader" type="x-shader/x-vertex">
attribute vec3 position;
void main(void) {
	gl_Position = vec4( position, 1.0 );
}
</script>

<script id="float_fragment_shader" type="x-shader/x-fragment">
precision highp float;

// uniforms
uniform float time;
uniform int frame;
uniform sampler2D buffer;
uniform vec2 resolution;

// camera
uniform vec3 cameraPosition;
uniform mat4 viewMatrix;

uniform mat4 cameraWorldMatrix;
uniform mat4 cameraProjectionMatrixInverse;
uniform mat4 cameraViewProjectionpMatrixInverse;
uniform float cameraNear;
uniform float cameraFar;

// consts
const float EPS = 1e-4;
const float OFFSET = EPS * 10.0;
const float PI = 3.14159;
const vec3 backgroundColor = vec3( 1.0 );
const vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );

struct Intersect {
    bool hit;

    vec3 position;
    float distance;
    vec3 normal;

    int material;
    vec3 color;
};

float hash( float seed ) {
    return fract( sin( seed ) * 43758.5453 );
}

vec3 cosineDirection( float seed, vec3 nor ) {
    // compute basis from normal
    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content
    // (link provided by nimitz)
    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);
    vec3 uu = vec3( tc.x, tc.z, -nor.x );
    vec3 vv = vec3( tc.z, tc.y, -nor.y );
    
    float u = hash( 78.233 + seed);
    float v = hash( 10.873 + seed);
    float a = 6.283185 * v;

    return sqrt( u ) * ( cos( a ) * uu + sin( a ) * vv ) + sqrt( 1.0 - u ) * nor;
}

float udFloor( vec3 p ){
	return dot( p, vec3( 0.0, 1.0, 0.0 ) ) + 1.0;
}

float sdSphere( vec3 p, float r ) {
	return length( p ) - r;
}

float sceneDistance( vec3 p ) {
	//return sdSphere( p, 1.0 );
	return min( udFloor( p ), sdSphere( p, 1.0 ) );
}

Intersect sceneIntersect( vec3 p ) {
	Intersect a;
	a.distance = sceneDistance( p );
	a.material = 0;
	return a;
}

vec3 calcNormal( vec3 p ) {
	vec2 e = vec2( 1.0, -1.0 ) * 0.001;
	return normalize(
		e.xyy * sceneDistance( p + e.xyy ) + e.yyx * sceneDistance( p + e.yyx ) + 
			e.yxy * sceneDistance( p + e.yxy ) + e.xxx * sceneDistance( p + e.xxx ) );
}

Intersect calcRadiance( inout vec3 origin, inout vec3 dir, int bounce, float sa ) {
	Intersect nearest;

	float d;
	float distance = 0.0;
	vec3 p = origin;

	for ( int i = 0; i < 200; i++ ){
		d = sceneDistance( p );
		distance += d;
		p = origin + distance * dir;
		if ( abs( d ) < EPS ) break;
	}

	if ( abs( d ) < EPS ) {
		nearest = sceneIntersect( p );
		nearest.position = p;
		nearest.normal = calcNormal( p );
		nearest.distance = distance;

		float diffuse = clamp( dot( lightDir, nearest.normal ), 0.1, 1.0 );
		//nearest.color = vec3( 0.5, 0.5, 0.5 ) * diffuse;
		nearest.color = vec3( 0.5, 0.5, 0.5 );

		nearest.hit = true;

		origin = p + OFFSET * nearest.normal;
		dir = cosineDirection(76.2 + 73.1*float(bounce) + sa + 17.7*float(frame), nearest.normal);
	} else {
		nearest.color = backgroundColor;
		nearest.hit = false;
	}

	return nearest;
}

void main( void ) {
	// previous color
	vec2 uv = gl_FragCoord.xy / resolution.xy;
	vec4 prevColor = texture2D( buffer, uv );

	// sa
	float sa = hash( dot( gl_FragCoord.xy, vec2(12.9898, 78.233) ) + 1113.1*float(frame) );

	// fragment position
	vec2 fragPos = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;

	// camera and ray
	vec3 origin = cameraPosition;
	vec4 rayTip = cameraWorldMatrix * cameraProjectionMatrixInverse * vec4( fragPos.xy, 1.0, 1.0 );
	vec3 ray = normalize( rayTip.xyz );

	// bounce
	vec3 color = vec3( 1.0 );
	for ( int i = 0; i < 3; i++ ) {
		Intersect nearest = calcRadiance( origin, ray, i, sa );
		color *= nearest.color;
		if ( !nearest.hit ) break;
	}

	gl_FragColor = vec4( prevColor.rgb + color, 1.0 );
	//gl_FragColor = vec4( color, 1.0 );
}
</script>

<script id="render_fragment_shader" type="x-shader/x-fragment">
precision highp float;

uniform int frame;
uniform vec2 resolution;
uniform sampler2D buffer;

void main(void) {
	vec2 uv = gl_FragCoord.xy / resolution.xy;
	vec4 color = texture2D( buffer, uv );
	gl_FragColor = vec4( color.rgb / float( frame + 1 ), 1.0 );
	//gl_FragColor = vec4( color.rgb, 1.0 );
}
</script>

		<script src="js/three.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>

			var container, stats;
			var camera, renderer;
			var orbitControls, prevOrbitControlsState = -1;
			var renderQuad;
			var floatQuad, initBuffer, readBuffer, writeBuffer, frame = 0;
			var clock = new THREE.Clock();

			var config = {
				saveImage: function() {
					renderer.render( renderQuad.scene, camera );
					window.open( canvas.toDataURL() );
				},
				camera: 'Orbit',

				resolution: '512',
			};

			init();
			animate();

			function createQuadScene( parameters ) {
				var scene = new THREE.Scene();
				var geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
				var material = new THREE.RawShaderMaterial( {
					uniforms: parameters.uniforms,
					vertexShader: parameters.vertexShader,
					fragmentShader: parameters.fragmentShader,
				} );
				var plane = new THREE.Mesh( geometry, material );
				plane.frustumCulled = false;
				plane.position.z = -1;
				scene.add( plane );

				return {
					scene: scene,
					geometry: geometry,
					material: material,
				};
			}

			function createDataTexture( width, height ) {
				var data = new Float32Array( width * height * 4 );
			
				for (var k = 0, kl = data.length; k < kl; k += 4) {
					data[k]      = 0.0;
					data[k + 1]  = 0.0;
					data[k + 2]  = 0.0;
					data[k + 3]  = 1.0;
				}
			
				var texture = new THREE.DataTexture(
					data,
					width,
					height,
					THREE.RGBAFormat,
					THREE.FloatType);
			
				texture.needsUpdate = true;
			
				return texture;
			}

			function createRenderTarget( width, height ) {
				return new THREE.WebGLRenderTarget( width, height, {
					wrapS: THREE.RepeatWrapping,
					wrapT: THREE.RepeatWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					stencilBuffer: false,
					depthBuffer: false
				});
			}

			function init() {

				initBuffer  = createDataTexture(  config.resolution, config.resolution );
				readBuffer  = createRenderTarget( config.resolution, config.resolution );
				writeBuffer = readBuffer.clone();

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 1, 8 );
				camera.lookAt( new THREE.Vector3( 0.0, 0.0, 0.0 ) );

				// float quad
				floatQuad = createQuadScene( {
					uniforms: {
						resolution: { type: 'v2', value: new THREE.Vector2( config.resolution, config.resolution ) },
						time: { type: 'f', value: 0.0 },
						frame: { type: 'i', value: frame },
						buffer: { type: 't', value: readBuffer.texture },

						cameraWorldMatrix: { type: 'm4', value: camera.matrixWorld },
						cameraProjectionMatrixInverse: { type: 'm4', value: new THREE.Matrix4().getInverse( camera.projectionMatrix ) },
						cameraViewProjectionpMatrixInverse: { type: 'm4', value: new THREE.Matrix4() },
						cameraNear: { type: 'f', value: camera.near },
						cameraFar:  { type: 'f', value: camera.far },
					},
					vertexShader: document.getElementById( 'vertex_shader' ).textContent,
					fragmentShader: document.getElementById( 'float_fragment_shader' ).textContent
				} );

				// render quad
				renderQuad = createQuadScene( {
					uniforms: {
						resolution: { type: 'v2', value: new THREE.Vector2( config.resolution, config.resolution ) },
						frame: { type: 'i', value: frame },
						buffer: { type: 't', value: writeBuffer.texture },
					},
					vertexShader: document.getElementById( 'vertex_shader' ).textContent,
					fragmentShader: document.getElementById( 'render_fragment_shader' ).textContent
				} );

				renderer = new THREE.WebGLRenderer();
				//renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( config.resolution, config.resolution );
				renderer.setClearColor( new THREE.Color( 0xffffff ) );
				canvas = renderer.domElement;
				container.appendChild( canvas );

				// check OES_texture_float
				if ( !renderer.extensions.get( "OES_texture_float" ) ) {
					alert( "No OES_texture_float support for float textures." );
					return;
				}

				orbitControls = new THREE.OrbitControls( camera, canvas );
				orbitControls.enablePan = true;
				orbitControls.keyPanSpeed = 0.01;
				orbitControls.enableDamping = false;
				orbitControls.dampingFactor = 0.015;
				orbitControls.enableZoom = true;
				orbitControls.zoomSpeed = 1;
				orbitControls.rotateSpeed = 0.8;
				orbitControls.autoRotate = false;
				orbitControls.autoRotateSpeed = 0.0;
				orbitControls.target = new THREE.Vector3( 0.0, 0.0, 0.0 );

				window.addEventListener( 'resize', onWindowResize, false );

				var gui = new dat.GUI();
				gui.add( config, 'saveImage' ).name( 'Save Image' );
				gui.add( config, 'camera', [ 'GLSL', 'Orbit' ] ).name( 'Camera' );

				// var shadowFolder = gui.addFolder('Shadow');
				// shadowFolder.add( config, 'shadowType', { Hard: 0, Soft1: 1, Soft2: 2 } ).name( 'Type');
				// shadowFolder.add( config, 'shadowIntensity', 0.0, 1.0 ).name( 'Intensity' );
				// shadowFolder.add( config, 'shadowSharpness', 0.0, 100.0 ).name( 'Sharpness' );
				// shadowFolder.open();

				gui.add( config, 'resolution', [ '256', '512', '800', 'full' ] ).name( 'Resolution' ).onChange( function( value ) {

					if ( value !== 'full' ) {

						canvas.width = value;
						canvas.height = value;

					}
					onWindowResize();

				} );

				stats = new Stats();
				document.body.appendChild( stats.domElement );

				onWindowResize();

			}

			function onWindowResize() {

				if ( config.resolution === 'full' ) {

					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;

				}

				camera.aspect = canvas.width / canvas.height;
				camera.updateProjectionMatrix();

				renderer.setSize( canvas.width, canvas.height );

			}

			function animate( timestamp ) {

				requestAnimationFrame( animate );
				render( timestamp );

			}

			function render( timestamp ) {

				var delta = clock.getDelta();

				stats.begin();

				if ( config.camera === "Orbit" ) {
					orbitControls.update();
					var state = orbitControls.getState();
					if ( state !== -1 ) {
						frame = 0;
					}
					prevOrbitControlsState = state;
				}

				// float quad
				{
					// set uniforms
					floatQuad.material.uniforms.resolution.value = new THREE.Vector2( canvas.width, canvas.height );
					floatQuad.material.uniforms.time.value = timestamp * 0.001;
					floatQuad.material.uniforms.frame.value = frame;
					floatQuad.material.uniforms.buffer.value = frame === 0 ? initBuffer : readBuffer.texture;

					// set camera uniforms
					{
						var cameraViewProjectionpMatrixInverse = camera.matrixWorld.clone();
						var cameraViewInverseMatrix = camera.matrixWorld;
						var cameraProjectionInverseMatrix = new THREE.Matrix4().getInverse( camera.projectionMatrix );
						//cameraViewProjectionpMatrixInverse.multiplyMatrices( cameraViewInverseMatrix, cameraProjectionInverseMatrix );
						cameraViewProjectionpMatrixInverse.multiply( cameraViewInverseMatrix );
						cameraViewProjectionpMatrixInverse.multiply( cameraProjectionInverseMatrix );
						floatQuad.material.uniforms.cameraViewProjectionpMatrixInverse.value = cameraViewProjectionpMatrixInverse;

						floatQuad.material.uniforms.cameraWorldMatrix.value = camera.matrixWorld;
						floatQuad.material.uniforms.cameraProjectionMatrixInverse.value = new THREE.Matrix4().getInverse( camera.projectionMatrix );

						floatQuad.material.uniforms.cameraNear.value = camera.near;
						floatQuad.material.uniforms.cameraFar.value  = camera.far;
					}

					renderer.render( floatQuad.scene, camera, writeBuffer );
				}

				// render quad
				{
					renderQuad.material.uniforms.resolution.value = new THREE.Vector2( canvas.width, canvas.height );
					renderQuad.material.uniforms.frame.value = frame;
					renderQuad.material.uniforms.buffer.value = writeBuffer.texture;

					renderer.render( renderQuad.scene, camera );
				}

				// swap buffers
				var tmpBuffer = writeBuffer;
				writeBuffer = readBuffer;
				readBuffer = tmpBuffer;

				stats.end();
				frame++;

			}

			// easy mobile device detection
			function isMobileDevice () {

				if ( navigator === undefined || navigator.userAgent === undefined ) {

					return true;

				}

				var s = navigator.userAgent;

				if (    s.match( /iPhone/i )
//				     || s.match( /iPad/i )
				     || s.match( /iPod/i )
				     || s.match( /webOS/i )
				     || s.match( /BlackBerry/i )
				     || ( s.match( /Windows/i ) && s.match( /Phone/i ) )
				     || ( s.match( /Android/i ) && s.match( /Mobile/i ) ) ) {

					return true;

				}

				return false;

			}

		</script>

	</body>
</html>
