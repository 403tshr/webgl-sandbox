<!DOCTYPE html>
<!--
Copyright (c) 2017 gam0022
Released under the MIT license
http://opensource.org/licenses/mit-license.php
-->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>three.js webgl - raymarching - carbon</title>
		<style type="text/css">
			body {
				background-color: black;
				margin: 0;
				padding: 0;
			}

			a { color: skyblue }

			canvas {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				margin: auto;
			}

			#info {
				color: white;
				font-size: 13px;
				position: absolute;
				bottom: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl raymarching example - carbon by <a href="https://github.com/gam0022" target="_blank">gam0022</a><br>
			Third place prize works in GLSL Compo, Tokyo Demo Fest 2016 (<a href="http://gam0022.net/blog/2016/02/24/tokyo-demo-fest/" target="_blank">article in Japanese</a>)
		</div>

		<script id="fragment_shader" type="x-shader/x-fragment">

#ifdef GL_ES
precision mediump float;
#endif

// uniforms
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// debug for camera
uniform bool debugCamera;
uniform vec3 cameraPos;
uniform vec3 cameraDir;

// consts
const float INF = 1e+10;
const float EPS = 1e-2;
const float OFFSET = EPS * 100.0;

const float PI = 3.14159265359;
const float PI2 = 6.28318530718;


// globals
const vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );
vec3 cPos, cDir;
vec3 sPos;
float sSize;
vec3 illuminationColor;
float tempo;

// ray
struct Ray {
	vec3 origin;
	vec3 direction;
};

#define METAL_MATERIAL 0
#define CIRCUIT_MATERIAL 1
#define MIRROR_MATERIAL  2
#define SKY_MATERIAL 4


// util
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

float noise(vec2 x) {
	vec2 i = floor(x), f = fract(x);

	float a = hash(i);
	float b = hash(i + vec2(1.0, 0.0));
	float c = hash(i + vec2(0.0, 1.0));
	float d = hash(i + vec2(1.0, 1.0));

	vec2 u = f * f * (3.0 - 2.0 * f);
	return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(vec2 p) {
	const mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);

	p.xy += time;

	float f = 0.5000 * noise(p); p = m2 * p * 2.02;
	f += 0.2500 * noise(p); p = m2 * p * 2.03;
	f += 0.1250 * noise(p); p = m2 * p * 2.01;
	f += 0.0625 * noise(p);
	return f / 0.9375;
}

// intersection
struct Intersection {
	bool hit;
	vec3 position;
	float distance;
	vec3 normal;
	vec2 uv;
	float count;

	int material;
	vec3 color;
};


// distance functions
vec3 opRep( vec3 p, float interval ) {
	return mod( p, interval ) - 0.5 * interval;
}

vec2 opRep( vec2 p, float interval ) {
	return mod( p, interval ) - 0.5 * interval;
}

float opRep( float p, float interval ) {
	return mod( p, interval ) - 0.5 * interval;
}

vec2 opRepLimit(vec2 p, float interval, float limit) {
	return mod(clamp(p, -limit, limit), interval) - 0.5 * interval;
}

// https://www.shadertoy.com/view/Mlf3Wj
mat2 rotate(in float a) {
    float s=sin(a),c=cos(a);
    return mat2(c,s,-s,c);
}

vec2 fold(in vec2 p, in float s) {
    float a = PI / s - atan(p.x, p.y);
    float n = PI2 / s;
    a = floor(a / n) * n;
    p *= rotate(a);
    return p;
}

float smoothMin(float d1, float d2, float k){
	float h = exp(-k * d1) + exp(-k * d2);
	return -log(h) / k;
}

// thanks to https://www.shadertoy.com/view/MdVGRc
float dMbox( vec3 p ) {
  const float scale = 2.7;
  const int n = 12;
  vec4 q0 = vec4 (p, 1.);
  vec4 q = q0;

  for ( int i = 0; i < n; i++ ) {

    q.xyz = clamp( q.xyz, -1.0, 1.0 ) * 2.0 - q.xyz;
    q = q * scale / clamp( dot( q.xyz, q.xyz ), 0.5, 1.0 ) + q0;

  }

  return length( q.xyz ) / abs( q.w );
}

float sdBox( vec3 p, vec3 b ) {
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float dSphere( vec3 p, vec3 c, float r ) {
	return length( p - c ) - r;
}

float dBar( vec2 p, float interval, float width) {
	return length( max( abs( opRep( p, interval ) ) - width, 0.0 ) );
}

float squareDistance( vec2 p ) {
	return p.x * p.x + p.y * p.y;
}

float gauss(float x) {
	float a = 50.0;
	return exp(-x * x / a);
}

float dWing( in vec3 p ) {
	float a = 0.07 + 0.07 * tempo;

	float b = min(time, 5.0) * gauss(length(p.xz));
	p.y += -b + 10.0;

	vec3 p1 = p;
	p1.xz = opRepLimit(p.xz, 1.0, 20.0);

	vec3 p2 = p;
	p2 = opRep( p, 0.5 );

	float d1 = sdBox( p1, vec3( 0.2 + a * 3.0, 12.0 - a,       0.2 + a ) );
	float d2 = sdBox( p1, vec3( 0.4 - a,       13.0 - 4.0 * a, 0.1 + a ) );
	float d3 = sdBox( p1, vec3( 0.3 - a,       14.0 - 4.0 * a, a ) );
	float d4 = sdBox( p2, vec3( 0.05 + a ) );
	return max( max( min( d1, d2 ), -d3), -d4 );
}

float easeInCubic( float t ) {
	return t * t * t;
}

float easeInOutCubic( float t ) {
	return t < 0.5 ? 4.0 * t * t * t : ( t - 1.0 ) * ( 2.0 * t - 2.0 ) * ( 2.0 * t - 2.0 ) + 1.0;
}

float dUfo( inout vec3 p ) {
	float t = time * 0.5;
	float t1 = floor( t );
	float t2 = t1 + easeInOutCubic( t - t1 );

	p.xz = fold( p.xz, min( t2, 10.0 ) );
	p.z -= 0.5;

	if ( 10.0 <= time && time < 20.0 ) {
		//p.x += 0.1 * tempo;
	}

	return dWing( p );
}

float dScene( vec3 p ) {
	return dUfo( p );
}


// color functions
vec3 hsv2rgb( vec3 c ) {

	vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );
	vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );
	return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );

}

// thanks to http://glslsandbox.com/e#21290.5
vec2 circuitPattern( vec2 p ) {

	p = fract(p);
	float r = 0.123;
	float v = 0.0, g = 0.0;
	r = fract(r * 9184.928);
	float cp, d;
	
	d = p.x;
	g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);
	d = p.y;
	g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);
	d = p.x - 1.0;
	g += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);
	d = p.y - 1.0;
	g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);
	
	const int iter = 15;
	for(int i = 0; i < iter; i ++)
	{
		cp = 0.5 + (r - 0.5) * 0.9;
		d = p.x - cp;
		g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);
		if(d > 0.0) {
			r = fract(r * 4829.013 * 2.0);
			p.x = (p.x - cp) / (1.0 - cp);
			v += 1.0;
		}
		else {
			r = fract(r * 1239.528);
			p.x = p.x / cp;
		}
		p = p.yx;
	}
	v /= float(iter);
	return vec2(g, v);

}

vec3 calcNormal( vec3 p ) {
	vec2 e = vec2( 1.0, -1.0 ) * 0.001;
	return normalize(
		e.xyy * dScene( p + e.xyy ) + e.yyx * dScene( p + e.yyx ) + 
			e.yxy * dScene( p + e.yxy ) + e.xxx * dScene( p + e.xxx ) );
}

void setMaterialAndUv( inout Intersection intersection, vec3 p ) {
	if ( abs( dUfo( p ) ) < EPS ) {
	}
	else {
	}

	intersection.material = METAL_MATERIAL;
	intersection.uv = p.xz;
}

//float getShadow( vec3 ro, vec3 rd ) {
//
//	float h = 0.0;
//	float c = 0.0;
//	float r = 1.0;
//	float shadowCoef = 0.5;
//
//	for ( float t = 0.0; t < 50.0; t++ ) {
//
//		h = dScene( ro + rd * c );
//
//		if ( h < EPS ) return shadowCoef;
//
//		r = min( r, h * 16.0 / c );
//		c += h;
//
//	}
//
//	return 1.0 - shadowCoef + r * shadowCoef;
//
//}

void intersectScene( inout Intersection intersection, inout Ray ray ) {
	float d;
	intersection.distance = 0.0;
	vec3 p = ray.origin;

	for ( float i = 0.0; i < 128.0; i++ ) {
		d = dScene( p );
		intersection.distance += d;
		p = ray.origin + intersection.distance * ray.direction;
		intersection.count = i;
		if (abs(d) < EPS) break;
	}

	if ( abs( d ) < EPS ) {
		intersection.hit = true;
		intersection.position = p;
		intersection.normal = calcNormal( p );
		setMaterialAndUv( intersection, p );
	}
}

void calcRadiance( inout Intersection intersection, inout Ray ray, int bounce ) {
	intersection.hit = false;
	intersectScene( intersection, ray );

	if ( intersection.hit ) {
		float diffuse = clamp( dot( lightDir, intersection.normal ), 0.1, 1.0 );
		float specular = pow( clamp( dot( reflect( lightDir, intersection.normal ), ray.direction ), 0.0, 1.0 ), 10.0 );
		float ao = 1.0 - 0.01 * float( min( intersection.count, 60.0 ) );
		//float shadow = getShadow( p + intersection.normal * OFFSET, lightDir );

		if ( intersection.material == METAL_MATERIAL ) {
			//intersection.color = vec3( 0.2 ) + 0.2 * diffuse + specular - 0.01 * float( intersection.count );
			//vec2 uv = intersection.uv;
			//vec2 dg = circuitPattern( uv );
			//float glow = max( sin( length( uv ) - 1.8 * time ) * 2.5, 0.0 );
			//float pattern = max( dg.x - 1.0, 0.0 );
			intersection.color = vec3( 0.2 ) + 0.2 * diffuse * ao + specular;
		}

		intersection.color = mix(intersection.color, 0.8 * vec3(0.7, 0.75, 0.8), min(1.0, pow(0.02 * intersection.distance, 2.0)));
	} else {
		vec3 base = vec3(0.4, 0.55, 0.8) * (1.0 - 0.8 * ray.direction.y) * 0.9;
		vec3 cloud = vec3(1.0, 0.95, 1.0);

		// Sun
		float sundot = clamp(dot(ray.direction, lightDir), 0.0, 1.0);
		base += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 8.0);
		base += 0.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 64.0);

		// Clouds
		intersection.color = mix(base, cloud, 0.5 *
			smoothstep(0.5, 0.8, fbm((ray.origin.xz + ray.direction.xz * (250000.0 - ray.origin.y) / ray.direction.y) * 0.000008)));

		intersection.color = mix(intersection.color, vec3(0.7, 0.75, 0.8), pow(1.0 - max(ray.direction.y, 0.0), 4.0));
	}
}


void main(void) {
	// fragment position
	vec2 fragPos = ( gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y );

	// camera and ray
	Ray ray;

	if ( debugCamera ) {
		cPos  = cameraPos;
		cDir  = cameraDir;
	} else {
		cPos  = vec3( -0.8185093402862549, 4.509979248046875, time );
		cDir  = normalize( vec3( sin( time * 0.5 ), sin( time * 0.1 ), cos( time * 0.6 ) + 0.5 ) );

		cPos = vec3( 0.0, 0.5, -5.0 );
		cDir = vec3( 0.0, 0.0, 1.0 );
	}

	float targetDepth = 1.3;
	vec3 up =  vec3( 0.0, 1.0 ,0.0 );
	vec3 cSide = normalize( cross( cDir, up ) );
	vec3 cUp   = normalize( cross( cSide, cDir ) );
	ray.origin = cPos;
	ray.direction = normalize( cSide * fragPos.x + cUp * fragPos.y + cDir * targetDepth );

	// music's tempo
	tempo = sin( PI * time );// + sin( 3.0 * PI * time ) + sin( 2.0 * PI * time ) + sin( PI * time );
	//tempo /= 4.0;

	// sphere pos
	float d = 0.2 + 0.1 * cos( time * 0.5 );
	sPos = cPos + vec3( 0.0, 0.0, d );
	sSize = 0.03 + 0.005 * tempo;

	// Illumination Color
	illuminationColor = hsv2rgb( vec3( time * 0.02 + 0.6, 1.0, 1.0 ) );

	vec3 color = vec3( 0.0 );
	float alpha = 1.0;
	Intersection intersection;

	for ( int bounce = 0; bounce <= 2; bounce++ ) {
		calcRadiance( intersection, ray, bounce );

		color += alpha * intersection.color;
		if ( !intersection.hit || intersection.material != METAL_MATERIAL ) break;

		alpha *= 0.5 * clamp(1.0 - 0.01 * intersection.distance, 0.0, 1.0);
		ray.origin = intersection.position + intersection.normal * OFFSET;
		ray.direction = normalize( reflect( ray.direction, intersection.normal ) );
	}

	//color += 0.2 * tempo;

	gl_FragColor = vec4( color, 1.0 );

}

		</script>

		<script id="vertex_shader" type="x-shader/x-vertex">

			attribute vec3 position;

			void main(void) {

				gl_Position = vec4(position, 1.0);

			}

		</script>

		<script src="js/three.min.js"></script>
		<script src="js/controls/FlyControls.js"></script>
		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>

			var camera, scene, flyControls, orbitControls, renderer;
			var geometry, material, plane;
			var mouse = new THREE.Vector2( 0.5, 0.5 );
			var canvas;
			var stats;

			var clock = new THREE.Clock();

			var config = {
				saveImage: function() {

					renderer.render( scene, camera );
					window.open( canvas.toDataURL() );

				},
				camera: 'Orbit',
				resolution: '512',
			};

			init();
			render();

			function init() {

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(35, 800/600);
				camera.position.y = 5;
				camera.lookAt( new THREE.Vector3( 0.0, 0.0, 0.0 ) );

				geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
				material = new THREE.RawShaderMaterial( {
					uniforms: {
						resolution: { type: 'v2', value: new THREE.Vector2( config.resolution, config.resolution ) },
						mouse: { type: 'v2', value: mouse },
						time: { type: 'f', value: 0.0 },
						debugCamera: { type: 'i', value: config.camera !== 'GLSL' },
						cameraPos: { type: 'v3', value: camera.getWorldPosition() },
						cameraDir: { type: 'v3', value: camera.getWorldDirection() },
					},
					vertexShader: document.getElementById( 'vertex_shader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader' ).textContent
				} );
				plane = new THREE.Mesh( geometry, material );
				plane.frustumCulled = false;
				scene.add( plane );

				renderer = new THREE.WebGLRenderer();
				//renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( config.resolution, config.resolution );

				canvas = renderer.domElement;
				//canvas.addEventListener( 'mousemove', onMouseMove );
				window.addEventListener( 'resize', onWindowResize );
				document.body.appendChild( canvas );

				//flyControls = new THREE.FlyControls( camera, canvas );
				//flyControls.autoForward = true;
				//flyControls.dragToLook = false;
				//flyControls.rollSpeed = Math.PI / 12;
				//flyControls.movementSpeed = 0.1;

				orbitControls = new THREE.OrbitControls( camera, canvas );
				orbitControls.enablePan = true;
				//orbitControls.keyPanSpeed = 0.01;
				orbitControls.enableDamping = false;
				//orbitControls.dampingFactor = 0.015;
				orbitControls.enableZoom = true;
				//orbitControls.zoomSpeed = 0.001;
				//orbitControls.rotateSpeed = 0.8;
				orbitControls.autoRotate = false;
				orbitControls.autoRotateSpeed = 0.0;
				orbitControls.target = new THREE.Vector3( 0.0, 0.0, 0.0 );

				var gui = new dat.GUI();
				gui.add( config, 'saveImage' ).name( 'Save Image' );
				gui.add( config, 'camera', [ 'GLSL', 'Orbit', /*'Fly'*/ ] ).name( 'Camera' );
				gui.add( config, 'resolution', [ '256', '512', '800', 'full' ] ).name( 'Resolution' ).onChange( function( value ) {

					if ( value !== 'full' ) {

						canvas.width = value;
						canvas.height = value;

					}
					onWindowResize();

				} );

				stats = new Stats();
				document.body.appendChild( stats.domElement );

			}

			function render( timestamp ) {

				var delta = clock.getDelta();

				stats.begin();

				if ( config.camera === "Fly" ) {

					flyControls.update( delta );

				} else if ( config.camera === "Orbit" ) {

					orbitControls.update();

				} else {

					//camera.position.set( mouse.x - 0.5, mouse.y * 4, timestamp );
					//camera.lookAt( new THREE.Vector3( 0.0, -0.3, 1.0 ).add( camera.position ) );

				}

				//if ( camera.position.y < 0 ) camera.position.y = 0;

				material.uniforms.resolution.value = new THREE.Vector2( canvas.width, canvas.height );
				material.uniforms.mouse.value = mouse;
				material.uniforms.time.value = timestamp * 0.001;
				//material.uniforms.time.value = 147.81;
				//material.uniforms.time.value = 62.68;
				//material.uniforms.time.value = 93.69;
				//material.uniforms.time.value = 67.86;
				material.uniforms.debugCamera.value = config.camera !== 'GLSL';
				material.uniforms.cameraPos.value = camera.getWorldPosition();
				material.uniforms.cameraDir.value = camera.getWorldDirection();
				renderer.render( scene, camera );

				stats.end();
				requestAnimationFrame( render );

				var pos = camera.getWorldPosition();
				var dir = camera.getWorldDirection();

				document.getElementById( 'info' ).innerHTML = ""
					+ pos.x + ", " + pos.y + ", " + pos.z + "<br />"
					+ dir.x + ", " + dir.y + ", " + dir.z + "<br />"
					+ timestamp * 0.001;

			}

			function onMouseMove( e ) {

				mouse.x = e.offsetX / canvas.width;
				mouse.y = e.offsetY / canvas.height;

			}

			function onWindowResize( e ) {

				if ( config.resolution === 'full' ) {

					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;

				}

				renderer.setSize( canvas.width, canvas.height );

			}

		</script>

	</body>
</html>
